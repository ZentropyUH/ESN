import os
from typing import Optional, Union

import numpy as np
from keras.src.initializers import RandomUniform
from keras.src.layers import Dense
from rich.progress import track

from keras_reservoir_computing import initializers
from keras_reservoir_computing.models import ReservoirComputer, ReservoirEnsemble
from keras_reservoir_computing.reservoirs import EchoStateNetwork, ESNCell
from keras_reservoir_computing.utils.data_utils import list_files_only
from keras_reservoir_computing.utils.general_utils import timer

from .config import (
    get_class_from_name,
    get_default_params,
    load_model_config,
    merge_with_defaults,
)


def load_model(filepath: str) -> ReservoirComputer:
    """
    Loads a model from a file.

    Parameters
    ----------
    filepath : str
        Path to the model file.

    Returns
    -------
    krc.models.ReservoirComputer
        The loaded reservoir computing model.

    Notes
    -----
    Ensure that the file at `filepath` is a valid model file previously saved via the
    `krc.models.ReservoirComputer.save` method.
    """
    model = ReservoirComputer.load(filepath)
    return model


def create_model(
    name: str,
    model_config: Union[str, dict],
    features: int,
    seed: Optional[int] = None,
    log: bool = False,
) -> ReservoirComputer:
    """
    Generates a reservoir computing model based on the provided configuration.

    Parameters
    ----------
    name : str
        Name of the model.
    model_config : str or dict
        Either the path to the dictionary specifying the model configuration or the dictionary itself.
        Must contain the keys 'feedback_init', 'feedback_bias_init', 'kernel_init', and 'cell'.
    features : int
        Number of output features for the readout layer.
    seed : int, optional
        Random seed for reproducibility. If None, a random seed is generated. Will have the hierarchy:
        1. Explicitly passed seed
        2. Seed from model_config (user-specified)
        3. Random seed generated by numpy.
    log : bool, optional
        Whether to log the process of creating the model. Defaults to False.

    Returns
    -------
    krc.models.ReservoirComputer
        The newly created reservoir computing model.

    Notes
    -----
    This function sets a seed for all random initializations if `seed` is not None.
    Otherwise, it randomly generates a seed to initialize the model parameters.
    """

    if isinstance(model_config, str):
        model_config = load_model_config(filepath=model_config)

    # If seed is explicitly passed, use it. Otherwise, fall back to model_config or generate one.
    seed = (
        seed
        if seed is not None
        else model_config.get("seed", np.random.randint(0, 1000000))
    )
    model_config["seed"] = seed  # Store in config for consistency

    def initialize_component(component_key, default_name, module):
        """Generalized initializer for feedback/kernel components."""
        component_name = model_config[component_key].get("name", default_name)
        component_class = get_class_from_name(component_name, module)

        user_params = model_config[component_key].get("params", {})
        default_params = get_default_params(component_class)

        params = merge_with_defaults(default_params, user_params, {"seed": seed})

        if log:
            print(f"{component_key} name:", component_name)
            print(f"{component_key} params:", params)

        return component_class(**params)

    # Initialize feedback and kernel using the helper function
    feedback_init = initialize_component(
        component_key="feedback_init", default_name="InputMatrix", module=initializers
    )

    kernel_init = initialize_component(
        component_key="kernel_init",
        default_name="WattsStrogatzGraphInitializer",
        module=initializers,
    )

    # Initialize feedback bias separately since it uses Keras's initializer
    feedback_bias_init = RandomUniform(**model_config["feedback_bias_init"], seed=seed)

    # Initialize cell
    cell_params = model_config["cell"]
    # TODO: Modify this when more cells are implemented
    # user_cell_params = model_config["cell"].get("params", None)
    # default_cell_params = get_default_params(ESNCell)
    # cell_params = merge_with_defaults(default_cell_params, user_cell_params)

    cell = ESNCell(
        **cell_params,
        input_initializer=feedback_init,
        input_bias_initializer=feedback_bias_init,
        kernel_initializer=kernel_init,
    )

    # Initialize reservoir
    reservoir = EchoStateNetwork(reservoir_cell=cell)

    # Initialize readout layer
    readout_layer = Dense(
        features, activation="linear", name="readout", trainable=False
    )

    # Create model
    model = ReservoirComputer(
        reservoir=reservoir, readout=readout_layer, seed=seed, name=name
    )

    return model


def create_ensemble(
    trained_models_folder_path: str,
    ensemble_name: str = "Reservoir_Ensemble",
    log: bool = False,
) -> ReservoirEnsemble:
    """
    Creates an ensemble model by loading multiple trained reservoir computing models.

    Parameters
    ----------
    trained_models_folder_path : str
        Path to the folder containing only the trained model files.
    ensemble_name : str, optional
        Name of the ensemble model. Defaults to "Reservoir_Ensemble".
    log : bool, optional
        Whether to log the process of loading models. Defaults to False.

    Returns
    -------
    krc.models.ReservoirEnsemble
        An ensemble model composed of all loaded reservoir computing models.

    Notes
    -----
    Each model contained in the ensemble is loaded from the trained model files found in `trained_models_folder_path`.
    """
    model_files = list_files_only(trained_models_folder_path)

    ensemble_models = []

    with timer("Loading models", log=log):
        for model_file in track(model_files, description="Loading models"):
            model = load_model(os.path.join(trained_models_folder_path, model_file))
            ensemble_models.append(model)

    ensemble = ReservoirEnsemble(
        reservoir_computers=ensemble_models, name=ensemble_name
    )

    return ensemble
